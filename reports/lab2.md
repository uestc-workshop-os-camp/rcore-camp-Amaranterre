# 功能实现

在`MemorySet`中实现了`mmap`以及`munmap`方法；在这两个实现的基础上，在`TaskControlBlock`实现了`mmap`和`munmap`方法。

 `mmap`通过创建`MapType::Framed`类型的虚拟页，实现了对当前地址空间中特定一段地址的虚拟内存的分配。

`munmap`实现了回收通过`mmap`分配的内存。

# 问答作业

1. 表项：
   - {63-54}: reserverd
   - {53-28}: PPN{2}
   - {27-19}: PPN{1}
   - {18-10}: PPN{0}
   - {9-8}: RSW
   - {7}: dirty位，表示这一位上次被清空后，这一页有没有被修改过。
   - {6}:access位，表示这一位上次被访问后，这一页有没有被访问过。
   - {5}: 不知道
   - {4}: 控制该页是否在U特权级下允许被访问。
   - {3}: 表示该页的内容是否允许被取指。
   - {2}: 表示该页的内容是否允许被读取。
   - {1}：表示该页的内容是否允许被写入。
   - {0}:表示该页是否有效

2. 缺页
   - 最经典的segmention error，即访问了非法segmention的内容。也有可能是访问权限，比如对没有 "X" 权限的页面取指。
   - 1.`CR2` 寄存器存储了**导致缺页异常的虚拟地址**。当发生缺页异常时，操作系统可以通过读取 `CR2` 来确定哪个虚拟地址引发了缺页。2.`CR3` 寄存器存储了当前进程的**页目录基地址**，也就是页表的物理地址。它用于地址转换过程中将虚拟地址映射到物理地址。通过`CR3`，操作系统可以找到引起缺页异常的进程的页表。3.`EIP`（32位模式下）或 `RIP`（64位模式下）寄存器保存了**触发缺页异常的指令的地址**。这个寄存器指向当前正在执行的指令，即引发缺页的指令地址。
   - 好处：题目中已经解释过了。
   - 10*2^30 / 2^12 * 8 = 20MB。
   - **如何实现lazy策略**：当要求分配内存时，尽量不创建新的表项（这样减少了表项操作），而是将现有的表项的lazy位标为`1`；如果当前表项对应的虚拟页范围超过了要求分配的虚拟页范围，则向下一级页表项递归，直到能标记`lazy` 位为1为止。当访问相应的虚拟页时，先看`lazy`位，再看`valid`位，只载入要访问的虚拟页并且访问后要将`lazy`位归0。
   - `lazy`和`valid`位都为0.

3. 双页表和单页表
   - 需要有一个页表基址寄存器。通过更改这个寄存器的值就能更改页表基址。
   - 使用页表项的"U"位。
   - 不用对内核表作单独隔离，实现更加方便；少了切换到内核页表的相关操作，可以提高性能。
   - 在双页表系统中，进程切换以及用户态切换时都需要切换页表；进程上下文切换或者进程开始终止时会切换页表。


# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > ChatGPT：关于Rust一些语法相关的内容。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > rcoreTutorial文档：https://learningos.cn/rCore-Tutorial-Guide-2024S。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。